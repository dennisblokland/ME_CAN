/* Generated by DBCC, see <https://github.com/howerj/dbcc> */
#include "ME_CAN.h"
#include <assert.h>

int ME_CAN::unpack_can_0x300_ME1_1(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	
	/* RPM: start-bit 0, length 16, endianess intel, scaling 1, offset 0 */
	RPM.SetValue((data[0] << 8) + (data[1] & 0xff));
	/* TPS: start-bit 16, length 16, endianess intel, scaling 0.1, offset 0 */
	TPS.SetValue(((data[2] << 8) + (data[3] & 0xff)) / 10.0);
	/* MAP: start-bit 32, length 16, endianess intel, scaling 0.01, offset 0 */
	MAP.SetValue(((data[4] << 8) + (data[5] & 0xff)) / 100.0);
	/* IAT: start-bit 48, length 16, endianess intel, scaling 0.1, offset 0 */
	IAT.SetValue(((data[6] << 8) + (data[7] & 0xff)) / 10.0);
	return 0;
}


int ME_CAN::unpack_can_0x301_ME1_2(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* RPM_HardLimit: start-bit 0, length 16, endianess intel, scaling 0.4, offset 0 */
	RPM_HardLimit.SetValue(((data[0] << 8) + (data[1] & 0xff)) * 0.4);
	/* Lambda_Trim: start-bit 32, length 16, endianess intel, scaling 0.01, offset 0 */
	Lambda_Trim.SetValue(((data[5] << 8) + (data[6] & 0xff)) / 100.0);
	/* AFRCurr_1: start-bit 16, length 8, endianess intel, scaling 0.05, offset 7.5 */
	AFRCurr_1.SetValue((data[2] & 0xff) * 0.05 + 7.5);
	/* AFRCurr_2: start-bit 24, length 8, endianess intel, scaling 0.05, offset 7.5 */
	AFRCurr_2.SetValue((data[3] & 0xff) * 0.05 + 7.5);
	/* AFR_Target: start-bit 48, length 8, endianess intel, scaling 0.05, offset 7.5 */
	AFR_Target.SetValue((data[4] & 0xff) * 0.05 + 7.5);
	/* Fuel_Eth_Perc: start-bit 56, length 8, endianess intel, scaling 0.5, offset 0 */
	Fuel_Eth_Perc.SetValue((data[7] & 0xff) * 0.5);
	return 0;
}

int ME_CAN::unpack_can_0x302_ME1_3(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* IgnAdvAngle: start-bit 0, length 16, endianess intel, scaling 0.1, offset 0 */
	IgnAdvAngle.SetValue(((data[0] << 8) + (data[1] & 0xff)) / 10.0);
	/* IgnDwell: start-bit 16, length 16, endianess intel, scaling 0.1, offset 0 */
	IgnDwell.SetValue(((data[2] << 8) + (data[3] & 0xff)) / 10.0);
	/* Pri_InjAngle: start-bit 32, length 16, endianess intel, scaling 0.1, offset 0 */
	Pri_InjAngle.SetValue(((data[4] << 8) + (data[5] & 0xff)) / 10.0);
	/* Pri_InjPw: start-bit 48, length 16, endianess intel, scaling 0.1, offset 0 */
	Pri_InjPw.SetValue(((data[6] << 8) + (data[7] & 0xff)) / 10.0);
	return 0;
}

int ME_CAN::unpack_can_0x303_ME1_4(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* Pri_InjDuty: start-bit 0, length 8, endianess intel, scaling 0.5, offset 0 */
	Pri_InjDuty.SetValue((data[0] & 0xff) * 0.5);
	/* Sec_InjDuty: start-bit 8, length 8, endianess intel, scaling 0.5, offset 0 */
	Sec_InjDuty.SetValue((data[1] & 0xff) * 0.5);
	/* Sec_InjAngle: start-bit 16, length 16, endianess intel, scaling 0.1, offset 0 */
	Sec_InjAngle.SetValue(((data[2] << 8) + (data[3] & 0xff)) / 10.0);
	/* Sec_InjPw: start-bit 32, length 16, endianess intel, scaling 0.1, offset 0 */
	Sec_InjPw.SetValue(((data[4] << 8) + (data[5] & 0xff)) / 10.0);
	/* Boost_Ctrl_Duty: start-bit 48, length 8, endianess intel, scaling 0.5, offset 0 */
	Boost_Ctrl_Duty.SetValue((data[6] & 0xff) * 0.5);
	return 0; 
}

int ME_CAN::unpack_can_0x304_ME1_5(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* Oil_T: start-bit 16, length 16, endianess intel, scaling 0.1, offset 0 */
	Oil_TEMP.SetValue((data[0] << 8) + (data[1] & 0xff) / 10.0);
	/* Oil_P: start-bit 16, length 16, endianess intel, scaling 0.1, offset 0 */
	Oil_PRESS.SetValue((data[2] << 8) + (data[3] & 0xff) / 10.0);
	/* CLT: start-bit 32, length 16, endianess intel, scaling 0.1, offset 0 */
	COOL_TEMP.SetValue((data[4] << 8) + (data[5] & 0xff) / 10.0);
	/* VBAT: start-bit 48, length 16, endianess intel, scaling 0.1, offset 0 */
	VBAT.SetValue((data[6] << 8) + (data[7] & 0xff) / 10.0);
	return 0;
}

int ME_CAN::unpack_can_0x305_ME1_6(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* Gear_Pos: start-bit 0, length 8, endianess intel, scaling 1, offset 0 */
	Gear_Pos.SetValue(data[0] & 0xff);
	/* MAP_Target: start-bit 8, length 16, endianess intel, scaling 0.01, offset 0 */
	MAP_Target.SetValue((data[1] << 8) + (data[2] & 0xff) / 100.0);
	/* Vehicle_Speed: start-bit 24, length 16, endianess intel, scaling 0.008, offset 0 */
	Vehicle_Speed.SetValue((data[3] << 8) + (data[4] & 0xff)  * 0.008);
	/* EPS_Ev_Msk: start-bit 40, length 16, endianess intel, scaling 1, offset 0 */
	EPS_Ev_Msk.SetValue((data[5] << 8) + (data[6] & 0xff));

	return 0;
}

int ME_CAN::unpack_can_0x306_ME1_7(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* Knock_Reading: start-bit 0, length 16, endianess intel, scaling 1, offset 0 */
	Knock_Reading.SetValue((data[0] << 8) + (data[1] & 0xff));
	/* Knock_Ign_Adv_Mod: start-bit 16, length 8, endianess intel, scaling 0.1, offset 0 */
	Knock_Ign_Adv_Mod.SetValue((data[2] & 0xff) * 0.1);
	/* Fuel_Press: start-bit 24, length 8, endianess intel, scaling 5, offset 0 */
	Fuel_Press.SetValue((data[3] & 0xff) * 5);
	/* Fuel_Temp: start-bit 32, length 8, endianess intel, scaling 1, offset 0 */
	Fuel_Temp.SetValue(data[4] & 0xff);
	/* EGT_1: start-bit 40, length 16, endianess intel, scaling 0.1, offset 0 */
	EGT_1.SetValue((data[5] << 8) + (data[6] & 0xff) / 10.0);
	
	return 0;
}

int ME_CAN::unpack_can_0x307_ME1_8(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* EGT_2: start-bit 0, length 16, endianess intel, scaling 0.1, offset 0 */
	EGT_2.SetValue((data[0] << 8) + (data[1] & 0xff) / 10.0);
	/* GPT_1: start-bit 16, length 16, endianess intel, scaling 1, offset 0 */
	GPT_1.SetValue((data[2] << 8) + (data[3] & 0xff));
	/* GPT_2: start-bit 32, length 16, endianess intel, scaling 1, offset 0 */
	GPT_2.SetValue((data[4] << 8) + (data[5] & 0xff));

	return 0;
}

int ME_CAN::unpack_can_0x340_ME1_In_1(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* Vehicle_Speed: start-bit 0, length 16, endianess intel, scaling 0.008, offset 0 */
	Vehicle_Speed_2.SetValue((data[0] << 8) + (data[1] & 0xff) * 0.008);
	
	return 0;
}


int ME_CAN::unpack_message(const unsigned long id, byte data[], uint8_t dlc) {
	
	assert(id < (1ul << 29)); /* 29-bit CAN ID is largest possible */
	assert(dlc <= 8);         /* Maximum of 8 bytes in a CAN packet */
	switch (id) {
	case 0x300: return unpack_can_0x300_ME1_1( data, dlc);
	case 0x301: return unpack_can_0x301_ME1_2(data, dlc);
	case 0x302: return unpack_can_0x302_ME1_3(data, dlc);
	case 0x303: return unpack_can_0x303_ME1_4(data, dlc);
	case 0x304: return unpack_can_0x304_ME1_5(data, dlc);
	case 0x305: return unpack_can_0x305_ME1_6(data, dlc);
	case 0x306: return unpack_can_0x306_ME1_7(data, dlc);
	case 0x307: return unpack_can_0x307_ME1_8(data, dlc);
	case 0x340: return unpack_can_0x340_ME1_In_1(data, dlc);
	default: break; 
	}
	return -1; 
}




