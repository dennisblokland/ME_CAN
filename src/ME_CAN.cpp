/* Generated by DBCC, see <https://github.com/howerj/dbcc> */
#include "ME_CAN.h"
#include <assert.h>

ME_CAN::ME_CAN()
{
}


int ME_CAN::unpack_can_0x300_ME1_1(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	
	/* RPM: start-bit 0, length 16, endianess intel, scaling 1, offset 0 */
	RPM = (data[0] << 8) + (data[1] & 0xff);
	/* TPS: start-bit 16, length 16, endianess intel, scaling 0.1, offset 0 */
	TPS = (data[2] << 8) + (data[3] & 0xff);
	/* MAP: start-bit 32, length 16, endianess intel, scaling 0.01, offset 0 */
	MAP = (data[4] << 8) + (data[5] & 0xff);
	/* IAT: start-bit 48, length 16, endianess intel, scaling 0.1, offset 0 */
	IAT = (data[6] << 8) + (data[7] & 0xff);
	return 0;
}


int ME_CAN::unpack_can_0x301_ME1_2(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* RPM_HardLimit: start-bit 0, length 16, endianess intel, scaling 0.4, offset 0 */
	RPM_HardLimit = (data[0] << 8) + (data[1] & 0xff);
	/* Lambda_Trim: start-bit 32, length 16, endianess intel, scaling 0.01, offset 0 */
	Lambda_Trim =  (data[5] << 8) + (data[6] & 0xff);
	/* AFRCurr_1: start-bit 16, length 8, endianess intel, scaling 0.05, offset 7.5 */
	AFRCurr_1 = data[2] & 0xff;
	/* AFRCurr_2: start-bit 24, length 8, endianess intel, scaling 0.05, offset 7.5 */
	AFRCurr_2 = data[3] & 0xff;
	/* AFR_Target: start-bit 48, length 8, endianess intel, scaling 0.05, offset 7.5 */
	AFR_Target = data[4] & 0xff;
	/* Fuel_Eth_Perc: start-bit 56, length 8, endianess intel, scaling 0.5, offset 0 */
	Fuel_Eth_Perc = data[7] & 0xff;
	return 0;
}

int ME_CAN::unpack_can_0x302_ME1_3(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* IgnAdvAngle: start-bit 0, length 16, endianess intel, scaling 0.1, offset 0 */
	IgnAdvAngle = (data[0] << 8) + (data[1] & 0xff);
	/* IgnDwell: start-bit 16, length 16, endianess intel, scaling 0.1, offset 0 */
	IgnDwell = (data[2] << 8) + (data[3] & 0xff);
	/* Pri_InjAngle: start-bit 32, length 16, endianess intel, scaling 0.1, offset 0 */
	Pri_InjAngle = (data[4] << 8) + (data[5] & 0xff);
	/* Pri_InjPw: start-bit 48, length 16, endianess intel, scaling 0.1, offset 0 */
	Pri_InjPw = (data[6] << 8) + (data[7] & 0xff);
	return 0;
}

int ME_CAN::unpack_can_0x303_ME1_4(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* Sec_InjAngle: start-bit 16, length 16, endianess intel, scaling 0.1, offset 0 */
	Sec_InjAngle = (data[2] << 8) + (data[3] & 0xff);
	/* Sec_InjPw: start-bit 32, length 16, endianess intel, scaling 0.1, offset 0 */
	Sec_InjPw = (data[4] << 8) + (data[5] & 0xff);
	/* Pri_InjDuty: start-bit 0, length 8, endianess intel, scaling 0.5, offset 0 */
	Pri_InjDuty = data[0] & 0xff;
	/* Sec_InjDuty: start-bit 8, length 8, endianess intel, scaling 0.5, offset 0 */
	Sec_InjDuty = data[1] & 0xff;
	/* Boost_Ctrl_Duty: start-bit 48, length 8, endianess intel, scaling 0.5, offset 0 */
	Boost_Ctrl_Duty = data[6] & 0xff;
	return 0; 
}

int ME_CAN::unpack_can_0x304_ME1_5(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	Oil_T = (data[0] << 8) + (data[1] & 0xff);
	/* Oil_P: start-bit 16, length 16, endianess intel, scaling 0.1, offset 0 */
	Oil_P = (data[2] << 8) + (data[3] & 0xff);
	/* CLT: start-bit 32, length 16, endianess intel, scaling 0.1, offset 0 */
	CLT = (data[4] << 8) + (data[5] & 0xff);
	/* VBAT: start-bit 48, length 16, endianess intel, scaling 0.1, offset 0 */
	VBAT = (data[6] << 8) + (data[7] & 0xff);
	return 0;
}

int ME_CAN::unpack_can_0x305_ME1_6(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* MAP_Target: start-bit 8, length 16, endianess intel, scaling 0.01, offset 0 */
	MAP_Target = (data[1] << 8) + (data[2] & 0xff);
	/* Vehicle_Speed: start-bit 24, length 16, endianess intel, scaling 0.008, offset 0 */
	Vehicle_Speed = (data[3] << 8) + (data[4] & 0xff);
	/* EPS_Ev_Msk: start-bit 40, length 16, endianess intel, scaling 1, offset 0 */
	EPS_Ev_Msk = (data[5] << 8) + (data[6] & 0xff);
	/* Gear_Pos: start-bit 0, length 8, endianess intel, scaling 1, offset 0 */
	Gear_Pos = data[0] & 0xff;
	return 0;
}

int ME_CAN::unpack_can_0x306_ME1_7(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* Knock_Reading: start-bit 0, length 16, endianess intel, scaling 1, offset 0 */
	Knock_Reading = (data[0] << 8) + (data[1] & 0xff);
	/* EGT_1: start-bit 40, length 16, endianess intel, scaling 0.1, offset 0 */
	EGT_1 = (data[5] << 8) + (data[6] & 0xff);
	/* Knock_Ign_Adv_Mod: start-bit 16, length 8, endianess intel, scaling 0.1, offset 0 */
	Knock_Ign_Adv_Mod = data[2] & 0xff;;
	/* Fuel_Press: start-bit 24, length 8, endianess intel, scaling 5, offset 0 */
	Fuel_Press = data[3] & 0xff;
	/* Fuel_Temp: start-bit 32, length 8, endianess intel, scaling 1, offset 0 */
	Fuel_Temp = data[4] & 0xff;
	return 0;
}

int ME_CAN::unpack_can_0x307_ME1_8(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* EGT_2: start-bit 0, length 16, endianess intel, scaling 0.1, offset 0 */
	EGT_2 = (data[0] << 8) + (data[1] & 0xff);
	/* GPT_1: start-bit 16, length 16, endianess intel, scaling 1, offset 0 */
	GPT_1 = (data[2] << 8) + (data[3] & 0xff);
	/* GPT_2: start-bit 32, length 16, endianess intel, scaling 1, offset 0 */
	GPT_2 = (data[4] << 8) + (data[5] & 0xff);

	return 0;
}

int ME_CAN::unpack_can_0x340_ME1_In_1(byte data[], uint8_t dlc) {
	
	assert(dlc <= 8);
	if (dlc < 8)
		return -1;
	/* Vehicle_Speed: start-bit 0, length 16, endianess intel, scaling 0.008, offset 0 */
	Vehicle_Speed = (data[0] << 8) + (data[1] & 0xff);
	
	return 0;
}


int ME_CAN::unpack_message(const unsigned long id, byte data[], uint8_t dlc) {
	
	assert(id < (1ul << 29)); /* 29-bit CAN ID is largest possible */
	assert(dlc <= 8);         /* Maximum of 8 bytes in a CAN packet */
	switch (id) {
	case 0x300: return unpack_can_0x300_ME1_1( data, dlc);
	case 0x301: return unpack_can_0x301_ME1_2(data, dlc);
	case 0x302: return unpack_can_0x302_ME1_3(data, dlc);
	case 0x303: return unpack_can_0x303_ME1_4(data, dlc);
	case 0x304: return unpack_can_0x304_ME1_5(data, dlc);
	case 0x305: return unpack_can_0x305_ME1_6(data, dlc);
	case 0x306: return unpack_can_0x306_ME1_7(data, dlc);
	case 0x307: return unpack_can_0x307_ME1_8(data, dlc);
	case 0x340: return unpack_can_0x340_ME1_In_1(data, dlc);
	default: break; 
	}
	return -1; 
}




